# rtu.py
# Mosaik Simulator representing a RTU
# originally developed by Chromik
# small adaptions/test outputs done by Verena, my comments are marked starting with "V: "
# version 0.2

import mosaik_api
import os
from datetime import datetime
from mosaikrtu import rtu_model
import logging
logger = logging.getLogger('demo_main')
ch = logging.StreamHandler()
ch.setLevel(logging.WARN)
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)
from topology_loader.topology_loader import topology_loader
from distutils.util import strtobool

try:
    os.remove('./outputs/output_during_rtu_step.txt')
except OSError:
    pass

META = {
    'type': 'time-based',
    'models': {
        'RTU': {
            'public': True,
            'params': ['rtu_ref'],
            'attrs': ['switchstates'],
        },
        'sensor': {
            'public': True,
            'params': ['node', 'branch'],  # V: Parameter
            'attrs': [
                'I_real', 'I_imag', 'Vm'
            ],  # V: Meters reading voltage and current -> Incoming values from simulation
        },
        'switch': {
            'public': True,
            'params':
            ['init_status', 'branch'
             ],  # read from the file and mark as "on" if line is online. 
            'attrs': ['online'],
        },
    },
}


class MonitoringRTU(mosaik_api.Simulator):
    def __init__(self):
        super().__init__(META)
        self.rtu_ref = ""
        self.conf = ""
        self.sid = None
        self.data = ""
        self.rtueid = ""
        self._rtus = []
        self.entities = {}
        self._entities = {}
        self._cache = {}
        self.worker = ""
        self.server = ""
        topoloader = topology_loader()
        conf = topoloader.get_config()
        global RECORD_TIMES
        RECORD_TIMES = bool(strtobool(conf['recordtimes'].lower()))

        global RTU_STATS_OUTPUT  # configuriert, ob die Daten in output/readings geschrieben werden sollen
        RTU_STATS_OUTPUT = False
        #RTU_STATS_OUTPUT = bool(strtobool(conf['rtu_stats_output'].lower()))

        #### Verena
        global fd_1
        fd_1 = open('./outputs/output_during_rtu_step.txt', 'w+')
        intro_text = "This file saves data generated by the rtu.py file.\nDuring the update process of all components in a simulation step, the file saves the name of the component, the register it should be written to and the value itself.\nThe code responsible for this outputs can be found in the step(self, time, inputs)-method.\n \n"
        fd_1.write(intro_text)
        ####

    def init(self, sid, time_resolution):
        if float(time_resolution) != 1.:
            raise ValueError('MonitoringRTU only supports time_resolution=1., but'
                             ' %s was set.' % time_resolution)
        self.sid = sid
        return self.meta

    def create(self, num, model, rtu_ref=None):
        rtu = []
        for i in range(num):
            rtu_idx = len(self._rtus)
            if rtu_ref:
                self.rtu_ref = rtu_ref
                self.conf = rtu_model.load_rtu(
                    self.rtu_ref
                )  # use rtu_model.load_rtu to load the configuration
                self.data = rtu_model.create_datablock(
                    self.conf
                )  # create_datablock should take the dt into account
                self._cache, entities = rtu_model.create_cache(
                    self.conf["registers"])
                self.server = rtu_model.create_server(self.conf, self.data)
                self.server.start()
            self._rtus.append(rtu)
            children = []
            for eid, attrs in sorted(entities.items()):
                assert eid not in self._entities
                self._entities[eid] = attrs
                if 'node' not in attrs:
                    print("Entity without the node is {}".format(eid))
                    print("Attrs: {}".format(attrs))
                children.append({
                    'eid': eid,
                    'type': attrs['etype'],
                    'node': attrs['node'],
                    'branch': attrs['branch'],
                })
            self.rtueid = rtu_model.make_eid('rtu', rtu_idx)
            rtu.append({
                'eid': self.rtueid,
                'type': 'RTU',
                'children': children,
            })
        return rtu

    def step(self, time, inputs, max_advance):
        commands = {}  # set commands for switches
        switchstates = {}
        src = self.sid + '.' + self.rtueid  # RTUSim-0.0-rtu%
        dest = 'PyPower-0.PyPower'  # V: <- PyPower Simulator from Simulation
        commands[src] = {}
        commands[src][dest] = {}

        fd_1.write("--- Starting one RTU step (for" + str(self.sid) + '.' +
                   str(self.rtueid) + "). ---\n")

        for s, v in self._cache.items():
            if 'switch' in s or 'transformer' in s:
                if self.data.get(
                        v['reg_type'], v['index'],
                        1)[0] != v['value']:  # TODO: operation on datablock!

                    if RTU_STATS_OUTPUT:  # V: write to output file "model_readings.csv"
                        rtu_model.save_readings(
                            self.sid, v['reg_type'] + str(v['index']), "state",
                            v['value'])

                    self._cache[s]['value'] = self.data.get(
                        v['reg_type'], v['index'], 1)[0]
                    switchstates[v['place']] = v['value']

                    if commands[src][dest] == {}:
                        commands[src][dest]['switchstates'] = switchstates
                    else:
                        commands[src][dest]['switchstates'].update(
                            switchstates)

        for eid, data in inputs.items():

            for attr, values in data.items():  # attr is like I_real etc.

                if attr in ['I_real', 'Vm']:
                    for src, value in values.items():
                        if "grid" in src:
                            continue
                        else:
                            src = src.split("-")[2]
                            dev_id = eid + "-" + src  # dev_id, e.g. sensor_2-node_d1, sensor_2-branch_17, sensor_1-branch_16
                            assert dev_id in self._cache

                            self._cache[dev_id]["value"] = value

                            self.data.set(
                                self.conf['registers'][dev_id][0],
                                self.conf['registers'][dev_id][1], value,
                                self.conf['registers'][dev_id][2]
                            )  # V: write the new values to the matching register

                            fd_1.write(
                                str(eid) + " " +
                                str(self.conf['registers'][dev_id][1]) + " " +
                                str(self._cache[dev_id]["value"]) + "\n"
                            )  # V: Write to output file "output_during_rtu_step.csv" the currently updated value as (name, register, value)

                            if RTU_STATS_OUTPUT:  # V: write to output file "model_readings.csv"
                                rtu_model.save_readings(
                                    self.sid, dev_id, attr, value)

        fd_1.write("--- One RTU step done (for" + str(self.sid) + '.' +
                   str(self.rtueid) + "). ---\n\n")

        if bool(switchstates) and RECORD_TIMES:
            rtu_model.log_event("NC")
        yield self.mosaik.set_data(commands)

        return time + 60

    def finalize(self):
        #self.worker.stop()
        #print("Worker Stopped")
        self.server.stop()
        print("Server Stopped")
        print("\n\n")
        print('Finished')

    def get_data(self, outputs
                 ):  # Return the data for the requested attributes in outputs
        #outputs is a dict mapping entity IDs to lists of attribute names whose values are requested:
        # 'eid_1': ['attr_1', 'attr_2', ...],
        #{    'eid_1: {}      'attr_1': 'val_1', 'attr_2': 'val_2', ...
        #print("Output of RTU: {}".format(outputs))
        data = {}
        for eid, attrs in outputs.items():
            for attr in attrs:
                try:
                    val = self._entities[eid][attr]
                except KeyError:
                    print("No such Key")
                    val = None
                data.setdefault(eid, {})[attr] = val
        return data


def main():
    return mosaik_api.start_simulation(MonitoringRTU())


if __name__ == '__main__':
    main()